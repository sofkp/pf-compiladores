struct Producto {
    codigo: i64,
    precio: i64,
    stock: i64
}

fn crear(c:i64, p:i64, s:i64) -> Producto {
    let prod = Producto { codigo:c, precio:p, stock:s };
    return prod;
}

fn valortotal(prod:Producto) -> i64 {
    return prod.precio * prod.stock;
}

fn venderunidades(prod:Producto, n:i64) -> Producto {
    let nuevo = Producto {
        codigo: prod.codigo,
        precio: prod.precio,
        stock: prod.stock - n
    };
    return nuevo;
}

fn sumararray(v:[i64;3]) -> i64 {
    let mut acc:i64 = 0;
    acc = acc + v[0];
    acc = acc + v[1];
    acc = acc + v[2];
    return acc;
}

fn main() {
    let p1 = crear(1001, 25, 10);
    let p2 = crear(1002, 40, 5);
    let p3 = crear(1003, 12, 20);

    println!("{}", p1.codigo);
    println!("{}", p2.codigo);
    println!("{}", p3.codigo);

    let v1 = valortotal(p1);
    let v2 = valortotal(p2);
    let v3 = valortotal(p3);

    println!("{}", v1);
    println!("{}", v2);
    println!("{}", v3);

    let arr = [v1, v2, v3];

    println!("{}",sumararray(arr));

    let p1v = venderunidades(p1, 3);
    let p2v = venderunidades(p2, 1);

    println!("{}", p1v.stock);
    println!("{}", p2v.stock);

    let mut s:i64 = p3.stock;
    while s > 15 {
        s = s - 2;
    }
    println!("{}", s);

    let mut acc:i64 = 0;
    for i in 0..3 {
        acc = acc + arr[i];
    }
    println!("{}", acc);

    if acc >= 200 {
        println!("{}", p1.codigo);
    } else {
        println!("{}", p2.codigo);
    }
}
